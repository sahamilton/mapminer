
Good Queries
// Dead Leads

select branches.branchname, 
leadsources.source, 
count(address_branch.address_id) as deadleads
from leadsources, branches, addresses, address_branch
left join opportunities on address_branch.id = opportunities.address_branch_id
left join activities on address_branch.address_id = activities.address_id
where address_branch.address_id = addresses.id
and address_branch.branch_id = branches.id
and addresses.lead_source_id = leadsources.id
and addresses.lead_source_id != 4
and address_branch.created_at < '2019-06-01'
and opportunities.id is null
and activities.id is null
group by branches.branchname, leadsources.source


// Open but Closed opportunities

select branchname, concat_ws(' ', persons.firstname, persons.lastname), concat_ws(' ', b.firstname, b.lastname) as createdby,  addresses.businessname, opportunities.title, opportunities.created_at, actual_close
from branches, branch_person, addresses, opportunities, persons, persons b

where opportunities.closed = 0
and opportunities.actual_close is not null
and opportunities.branch_id = branches.id
and branches.id = branch_person.branch_id
and branch_person.role_id = 9
and branch_person.person_id = persons.id
and opportunities.user_id = b.user_id
and opportunities.address_id = addresses.id
order by branches.id
/*********************************************
SELECT branch_id, 
COUNT(IF(created_at <= DATE_SUB(NOW(), INTERVAL 1 month), 1, null)) AS month, 
COUNT(IF(created_at <= DATE_SUB(NOW(), INTERVAL 2 month), 1, null)) AS 2month,
COUNT(IF(created_at <= DATE_SUB(NOW(), INTERVAL 3 month), 1, null)) AS 3month,
COUNT(IF(created_at <= DATE_SUB(NOW(), INTERVAL 4 month), 1, null)) AS 4month,
COUNT(IF(created_at <= DATE_SUB(NOW(), INTERVAL 5 month), 1, null)) AS 5month,
COUNT(IF(created_at <= DATE_SUB(NOW(), INTERVAL 6 month), 1, null)) AS 6month
from opportunities
group by branch_id

//*************************************************

SELECT branch_id,count(*)
FROM `opportunities` 
where
closed = 1
and actual_close  between date('2019-04-01') and date('2019-04-08')
group by branch_id;


// Get all branch activities grouped by week, activity type & branch

select  a.branchname,
         concat_ws(' ',firstname,lastname) as manager, 
         STR_TO_DATE(concat(CAST(week AS CHAR),' Monday'),'%X%V %W') as weekbegin, 
         a.activity, 
         a.activitycount
        from persons, branch_person, branches, 
        (
            select branchname, 
            concat(YEAR(activity_date),
            WEEK(activity_date)) as week,
            activity, count(activities.id) as activitycount
            from activities, branches, activity_type 
            where activities.activity_date between '2019-07-01'  and '2019-07-31' 
            and activities.activitytype_id = activity_type.id 
            and activities.completed =1 
            and branch_id = branches.id
            group by branchname, week, activity ) a
          where persons.id = branch_person.person_id
          and branch_person.role_id = 9
          and branch_person.branch_id = branches.id
          and branches.branchname = a.branchname  
          ORDER BY `a`.`week`  ASC

//******************************************************************

SELECT branch_id,count(*)
FROM `activities` 
where
activitytype_id = 4
and activity_date  between date('2019-04-01') and date('2019-04-08')
group by branch_id;

//***************** Open Opportunities Aging
select count(id) as open, 
round(datediff( now(), created_at) / 7)) as weeks, 
branch_id from opportunities 
where opportunities.closed is null or opportunities.closed = 0 
group by branch_id, weeks ORDER BY `branch_id`, weeks


/// Weekly Report

select branches.id,branches.branchname, a.salesmeetings,b.opportunitieswon,b.value from 

branches

left join 
(select branch_id, count(activities.id) as salesmeetings 
 from activities 
 where activities.activitytype_id = 4 
 and activities.activity_date between date('2019-04-01') 
 and date('2019-04-14') 
 group by activities.branch_id) a 
 
 on branches.id = a.branch_id
 
 left join (
     select opportunities.branch_id, count(opportunities.id) as opportunitieswon,sum(value) as value 
     from opportunities 
     where opportunities.closed = 1 
     and opportunities.actual_close between date('2019-04-01') 
     and date('2019-04-14') 
     group by opportunities.branch_id) b 
     
     on branches.id = b.branch_id  
ORDER BY `b`.`opportunitieswon`  DESC 

///


insert ignore into address_branch 
(address_id,branch_id, top50)
select distinct address_id,branch_id,top50
from opportunities 
where opportunities.address_branch_id =0
//*************************************************
update opportunities,address_branch
set opportunities.address_branch_id = address_branch.id
where opportunities.address_id = address_branch.address_id
and opportunities.branch_id = address_branch.branch_id
and opportunities.address_branch_id = 0

//*************************************************

update opportunities, address_branch,activities
set closed = 2 where activities.activitytype_id = 9
and opportunities.address_branch_id = address_branch.id
and address_branch.address_id = activities.address_id
//*************************************************
SELECT addresses.id, businessname, addresses.street,addresses.city,addresses.state,branches.id as branchid,branchname, ST_Distance_Sphere(branches.position,addresses.position)  as distance
FROM `addresses`,address_branch,branches
where addresses.id = address_branch.address_id 
and address_branch.branch_id = branches.id
and branches.id in (1115,1149,1150,2254,2255,2702,2751,2752,2753,2961)
ORDER BY addresses.id, distance asc
//**************************************************
update addresses set position = POINT(lng, lat);
update addresses set position = ST_GeomFromText(ST_AsText(position), 4326);
update branches set position = POINT(lng, lat);
update branches set position = ST_GeomFromText(ST_AsText(position), 4326);
update persons set position = POINT(lng, lat);
update persons set position = ST_GeomFromText(ST_AsText(position), 4326);
//**************************************************
select addresses.id, addresses.businessname, concat_ws(' ',addresses.street,addresses.city,addresses.state) as fullAddress,addresses.lat,addresses.lng,branches.id,branches.branchname,branches.lat,branches.lng,
ST_Distance_Sphere(addresses.position,branches.position)/40633 AS distance
from addresses,address_branch, branches
where addresses.id = address_branch.address_id
and address_branch.branch_id in ('1506','1518','1522','1525','1552','1589')
//**************************************************
select branches.id,branchname, slc( 40.716743, -73.951368, branches.lat, branches.lng) as distance_in_meters,  astext(branches.position) 
from branches,addresses_import
where MBRContains(envelope(linestring(point(addresses_import.max(lng), addresses_import.max(lat)), point(addresses_import.min(lng), addresses_import.min(lat))), branches.position) 
order by distance_in_meters limit 10
//**************************************************

SELECT 
       CONCAT('LINESTRING(',
              max(lat)-0.5,' ',min(lng)-0.5,
              ',', 
              min(lat)+0.5 ,' ',max(lng) +0.5,
              ')') AS box
   FROM addresses_import

//*************************************************
   SELECT *
  FROM branches
 WHERE MBRContains(
        GeomFromText( envelope('LINESTRING(33.20434400000000 -118.47817100000000,34.09832500000000 -117.35715400000000)') ),
       	POINT(lng, lat))

//*****************************************
select persons.user_id,  activities.id
from persons,branch_person,address_branch,activities
where persons.id = branch_person.person_id
and branch_person.role_id = 9
and branch_person.branch_id = address_branch.branch_id
and address_branch.address_id = activities.address_id
and activities.user_id = 0;

//*****************************************
SELECT activities.id, persons.user_id FROM `activities`,address_branch,branch_person,persons WHERE activities.user_id =0 and activities.address_id = address_branch.address_id and address_branch.branch_id = branch_person.branch_id and branch_person.person_id = persons.id
//***************************************
insert into activities

(`activity_date`,`activitytype_id`,`address_id`,`branch_id`,`user_id`,`relatedActivity`,`created_at`,`note`)
select * from (SELECT
          `followup_date`,'12',`address_id`,`branch_id`,`user_id`,`id`,`created_at`, concat_ws(' ','----',note,'----') from activities where followup_date is not null) b;


update`activities` set completed = 1 WHERE activity_date < '2019-03-30';

**********************************************************************
get closed won opportunities by branch / date
SELECT branch_id,DATE_FORMAT(actual_close, '%Y/%m/%d') as dateclosed, count(id) 
FROM `opportunities` 
WHERE actual_close is not null
and actual_close between cast('2019-01-01' as date) and cast('2019-03-31' as date)
group by branch_id,dateclosed

*********************************************************************
Get sales appt activities by branch / date
SELECT address_branch.branch_id as branch,DATE_FORMAT(activity_date, '%Y/%m/%d') as activitydate, count(activities.id) 
FROM `activities` , address_branch
WHERE activity_date between cast('2019-01-01' as date) and cast('2019-03-31' as date)
and activitytype_id =4
and activities.address_id = address_branch.address_id
group by branch,activitydate

**************************************************
Get all opportunities, activities, contacts for branch
select addresses.id as aid, addresses.businessname,addresses.street,addresses.city,addresses.state,addresses.zip,addresses.phone,addresses.lat,addresses.lng, 
address_branch.id as abid,
opportunities.id as oppid, opportunities.description,opportunities.comments,opportunities.expected_close,opportunities.closed, opportunities.top50,opportunities.value,opportunities.requirements,opportunities.actual_close,opportunities.duration, 
activities.id as actid, activities.activity_date,activities.activitytype_id,activities.followup_date,activities.note, 
contacts.id as cid, contacts.fullname,contacts.firstname,contacts.lastname,contacts.title,contacts.contactphone,contacts.email from addresses,address_branch left join opportunities on address_branch.id = opportunities.address_branch_id left join activities on address_branch.address_id = activities.address_id left join contacts on address_branch.address_id = contacts.address_id where address_branch.branch_id = 7383 and address_branch.address_id = addresses.id
///
25502,52206,186508,186510,186513,186514,186516,186518,186521,186522,186523,186524,186525,186529,186530,186532,186534,186541,336208,336210,336215,336235,336772,336778,336806,336818,337387,338053,338062,338910,346450,346746,346806,346879,346908,346930,347126,347216,348528,348554,348632,349264,349311,349320,349323,358967,359037,391242,391244,391249,391268,391273,392636,392642

SELECT 
    IF(ISNULL(user_id), 'NULL', 'NOT NULL') as myfield, 
    COUNT(*) 
FROM addresses 

GROUP BY myfield
****************************************************
KPI's
****************************************************
// branch_id   leads   opportys  leadconv  lagdays   velocitydays  avgdeal  won

select address_branch.branch_id,
count(address_branch.id) as leads,
count(b.id) + count(c.id) + count(d.id) as opptys,
count(a.id) / count(address_branch.id) as conv,
avg(datediff(a.created_at, address_branch.created_at)) as lagdays,
avg(datediff(a.actual_close, a.created_at)) as velocitydays,
avg(a.value) as avgdeal,
count(b.id) as open,
count(c.id) as won,
count(d.id) as lost,
count(c.id) / (count(c.id) + count(d.id)) as winratio
from address_branch

left join opportunities a on address_branch.id = a.address_branch_id
left join opportunities b on address_branch.id = b.address_branch_id and b.closed = 0
left join opportunities c on address_branch.id = c.address_branch_id and c.closed = 1
left join opportunities d on address_branch.id = d.address_branch_id and d.closed = 2
where address_branch.created_at > '2019-03-01'
//where address_branch.branch_id in ()
group by address_branch.branch_id

//////////////////////////////
select branchname,count(opportunities.id),count(opportunities.top50)
from branches,opportunities
where branches.id = opportunities.branch_id
and opportunities.closed = 0
group by branchname
/////////////////////////////////////////////////

branch::whereHas(opportunities,function($q){
  $q->where('closed','=',0);
})->select('branchname', DB::raw('count(opportunities.id) as open,count(opportunities.top50 as top50'))->groupBy('branchname')->get();


 /// Get random addresses

SELECT @min := MIN(id), @max := MAX(id) FROM addresses;
SELECT DISTINCT id, businessname, street, address2, city, state, zip, lat, lng FROM addresses AS a JOIN ( SELECT FLOOR(@min + (@max - @min + 1) * RAND()) AS id FROM addresses LIMIT 50 -- more than 10 (to compensate for dups) ) b USING (id) LIMIT 25

<<<<<<< Updated upstream

/////////////////////////////////////////////////
Check if branch managers report to the branches MM

SELECT a.branch_id, 
    concat_ws(' ', c.firstname, c.lastname) as 'Branch Manager', 
    concat_ws(' ', e.firstname, e.lastname) as 'Reports to Manager',
    concat_ws(' ', f.firstname, f.lastname) as 'Who Reports',
    concat_ws(' ', d.firstname, d.lastname) as 'Branch MM',
    concat_ws(' ', g.firstname, g.lastname) as 'Who Reports'
    
from persons c, persons d, persons e, persons f, persons g, branch_person a

left join branch_person b
on a.branch_id = b.branch_id

where a.role_id = 9
and c.deleted_at is null
and d.deleted_at is null
and b.role_id = 3
and a.person_id = c.id
and b.person_id != c.reports_to
and b.person_id = d.id
and c.reports_to = e.id
and e.reports_to = f.id
and d.reports_to = g.id
=======
/////////////////// Open Opportunities with no expected close date
select branches.id, branchname, concat_ws(' ', firstname, lastname), title, value, opportunities.created_at
from opportunities, branches, persons, branch_person
where opportunities.expected_close = null
and opportunities.closed = 0
and opportunities.branch_id = branches.id
and branches.id = branch_person.branch_id
and branch_person.role_id = 9
and branch_person.person_id = persons.id
and persons.deleted_at is null
>>>>>>> Stashed changes

///////////// Find branches with multiple managers
SELECT branch_id, count(person_id) as COUNT FROM `branch_person`, persons WHERE role_id = 9 and persons.id = person_id and persons.deleted_at is null group by branch_id having count >1


/////////////////////////////////////
//Get leads with no activities or opportunities for region

SELECT addresses.*, address_branch.branch_id, leadsources.source 
FROM `addresses`, leadsources, address_branch 
left join activities on address_branch.address_id = activities.address_id 
left join opportunities on address_branch.id = opportunities.address_branch_id WHERE addresses.lead_source_id = leadsources.id 
and address_branch.address_id = addresses.id 
and address_branch.branch_id in (1711, 1702, 1701, 1719, 1707, 1713, 1788, 3024, 1754, 1752, 1780, 2924, 1750, 1742, 1751, 2855, 1749, 1770, 1771, 2852, 7250, 1753, 1740, 1756, 8026, 2898, 2928, 8064, 2861, 1767, 1807, 1852, 1459, 2814, 1746, 1806, 2931, 1802, 2643, 1794, 1748, 1808, 1460) 
and activities.id is null 
and opportunities.id is null

//////
REmoved from branch.php

    /*
    Calculate bounding box coordinates

    
    private function _getPositionCoordinates($lat, $lng, $distance)
    {
        

        $coordinates['lat']= $lat;
        $coordinates['lon'] = $lng;
        $coordinates['dist'] = $distance;
        $location = Geolocation::fromDegrees($lat, $lng);
        $box = $location->boundingCoordinates($distance, 'mi');

        $coordinates['rlon1'] = $box['min']->degLon;
        $coordinates['rlon2'] = $box['max']->degLon;
        $coordinates['rlat1'] = $box['min']->degLat;
        $coordinates['rlat2'] = $box['max']->degLat;
    
        return $coordinates;
    }
    */
   
   /* Details of opportunties
   select branch_id, branchname, businessname, title, opportunities.created_at, duration, requirements, value, expected_close
from opportunities, branches, addresses
where closed =0
and expected_close > '2019-09-15'
and opportunities.branch_id = branches.id
and opportunities.address_id = addresses.id
order by branch_id
    */
/************** Companies with location count
SELECT companies.id, companyname,  type, count(addresses.id) as locations
FROM `companies`, accounttypes, addresses
WHERE accounttypes_id = accounttypes.id
and companies.id = addresses.company_id
group by companies.id, companyname, type
order by companyname
*/

/* get activities of user

select addresses.id, businessname, activity, activity_date, opportunities.id, opportunities.title
from  addresses, activity_type, activities
left join opportunities on activities.address_id = opportunities.address_id
where activities.user_id = 3693
and activities.completed = 1 
and activities.address_id = addresses.id
and activities.activitytype_id = activity_type.id


/** debugging reports
select activities.id, activity_date, address_id, activities.created_at, user_id, activity
from activities, activity_type
where branch_id = 1509  
and completed = 1
and activities.created_at > '2019-11-20'
and activities.created_at < '2019-11-21'
and activities.activitytype_id = activity_type.id


 */

/*      Spatial duplicates query
select addresses_import.id as id, addresses.id as import_ref from addresses,addresses_import where addresses.company_id = addresses_import.company_id and addresses_import.company_id = 388 and ST_Distance_Sphere(addresses.position,addresses_import.position) < 50
*/

SELECT 
    a.businessname,
    COUNT(a.id) 
    FROM addresses a, addresses b
    left join address_branch on b.id = address_branch.address_id
    where a.company_id = 388 
    and a.company_id = b.company_id
    and ST_Distance_Sphere(a.position, b.position) < 50
    and address_branch.address_id is null
GROUP BY a.businessname
HAVING COUNT(a.id) > 1
Order By count(a.id) DESC;

/**** delete addresses without address_branch
delete addresses, address_branch from addresses left join address_branch on addresses.id = address_branch.address_id where addresses.company_id = 388 and address_branch.address_id is null

//*********** Sales Reps within 25 miles
select 
    addresses.id,
    addresses.businessname,
    addresses.street as addressestreet, 
    addresses.city as loccity, 
    addresses.state as addressestate,
    addresses.zip as loczip,
    persons.id as pid,
    users.employee_id,
    concat_ws(' ',persons.firstname,persons.lastname) as repname,
    persons.phone,
     3956 * acos(cos(radians(addresses.lat)) 
            * cos(radians(persons.lat)) 
            * cos(radians(persons.lng) 
            - radians(addresses.lng)) 
            + sin(radians(addresses.lat)) 
            * sin(radians(persons.lat))) as distance
    from addresses, persons, role_user, users
    where addresses.company_id = 38
    and persons.user_id = role_user.user_id
    and role_user.role_id = 5
    and persons.user_id = users.id
    and
            3956 * acos(cos(radians(addresses.lat)) 
            * cos(radians(persons.lat)) 
            * cos(radians(persons.lng) 
            - radians(addresses.lng)) 
            + sin(radians(addresses.lat)) 
            * sin(radians(persons.lat))) < 25