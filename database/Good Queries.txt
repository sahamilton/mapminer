Good Queries

//       Open but Closed opportunities

select branchname, concat_ws(' ', persons.firstname, persons.lastname), concat_ws(' ', b.firstname, b.lastname) as createdby,  addresses.businessname, opportunities.title, opportunities.created_at, actual_close
from branches, branch_person, addresses, opportunities, persons, persons b

where opportunities.closed = 0
and opportunities.actual_close is not null
and opportunities.branch_id = branches.id
and branches.id = branch_person.branch_id
and branch_person.role_id = 9
and branch_person.person_id = persons.id
and opportunities.user_id = b.user_id
and opportunities.address_id = addresses.id
order by branches.id


//*************************************************

SELECT branch_id,count(*)
FROM `opportunities` 
where
closed = 1
and actual_close  between date('2019-04-01') and date('2019-04-08')
group by branch_id;


// Get all branch activities grouped by week, activity type & branch

select  a.branchname,
         concat_ws(' ',firstname,lastname) as manager, 
         STR_TO_DATE(concat(CAST(week AS CHAR),' Monday'),'%X%V %W') as weekbegin, 
         a.activity, 
         a.activitycount
        from persons, branch_person, branches, 
        (
            select branchname, 
            concat(YEAR(activity_date),
            WEEK(activity_date)) as week,
            activity, count(activities.id) as activitycount
            from activities, branches, activity_type 
            where activities.activity_date between '2019-07-01'  and '2019-07-31' 
            and activities.activitytype_id = activity_type.id 
            and activities.completed =1 
            and branch_id = branches.id
            group by branchname, week, activity ) a
          where persons.id = branch_person.person_id
          and branch_person.role_id = 9
          and branch_person.branch_id = branches.id
          and branches.branchname = a.branchname  
          ORDER BY `a`.`week`  ASC

//******************************************************************

SELECT branch_id,count(*)
FROM `activities` 
where
activitytype_id = 4
and activity_date  between date('2019-04-01') and date('2019-04-08')
group by branch_id;

//***************** Open Opportunities Aging
select count(id) as open, 
round(datediff( now(), created_at) / 7)) as weeks, 
branch_id from opportunities 
where opportunities.closed is null or opportunities.closed = 0 
group by branch_id, weeks ORDER BY `branch_id`, weeks


/// Weekly Report

select branches.id,branches.branchname, a.salesmeetings,b.opportunitieswon,b.value from 

branches

left join 
(select branch_id, count(activities.id) as salesmeetings 
 from activities 
 where activities.activitytype_id = 4 
 and activities.activity_date between date('2019-04-01') 
 and date('2019-04-14') 
 group by activities.branch_id) a 
 
 on branches.id = a.branch_id
 
 left join (
     select opportunities.branch_id, count(opportunities.id) as opportunitieswon,sum(value) as value 
     from opportunities 
     where opportunities.closed = 1 
     and opportunities.actual_close between date('2019-04-01') 
     and date('2019-04-14') 
     group by opportunities.branch_id) b 
     
     on branches.id = b.branch_id  
ORDER BY `b`.`opportunitieswon`  DESC 

///


insert ignore into address_branch 
(address_id,branch_id, top50)
select distinct address_id,branch_id,top50
from opportunities 
where opportunities.address_branch_id =0
//*************************************************
update opportunities,address_branch
set opportunities.address_branch_id = address_branch.id
where opportunities.address_id = address_branch.address_id
and opportunities.branch_id = address_branch.branch_id
and opportunities.address_branch_id = 0

//*************************************************

update opportunities, address_branch,activities
set closed = 2 where activities.activitytype_id = 9
and opportunities.address_branch_id = address_branch.id
and address_branch.address_id = activities.address_id
//*************************************************
SELECT addresses.id, businessname, addresses.street,addresses.city,addresses.state,branches.id as branchid,branchname, ST_Distance_Sphere(branches.position,addresses.position)  as distance
FROM `addresses`,address_branch,branches
where addresses.id = address_branch.address_id 
and address_branch.branch_id = branches.id
and branches.id in (1115,1149,1150,2254,2255,2702,2751,2752,2753,2961)
ORDER BY addresses.id, distance asc
//**************************************************
update addresses set position = POINT(lng, lat);
update addresses set position = ST_GeomFromText(ST_AsText(position), 4326);
update branches set position = POINT(lng, lat);
update branches set position = ST_GeomFromText(ST_AsText(position), 4326);
update persons set position = POINT(lng, lat);
update persons set position = ST_GeomFromText(ST_AsText(position), 4326);
//**************************************************
select addresses.id, addresses.businessname, concat_ws(' ',addresses.street,addresses.city,addresses.state) as fullAddress,addresses.lat,addresses.lng,branches.id,branches.branchname,branches.lat,branches.lng,
ST_Distance_Sphere(addresses.position,branches.position)/40633 AS distance
from addresses,address_branch, branches
where addresses.id = address_branch.address_id
and address_branch.branch_id in ('1506','1518','1522','1525','1552','1589')
//**************************************************
select branches.id,branchname, slc( 40.716743, -73.951368, branches.lat, branches.lng) as distance_in_meters,  astext(branches.position) 
from branches,addresses_import
where MBRContains(envelope(linestring(point(addresses_import.max(lng), addresses_import.max(lat)), point(addresses_import.min(lng), addresses_import.min(lat))), branches.position) 
order by distance_in_meters limit 10
//**************************************************

SELECT 
       CONCAT('LINESTRING(',
              max(lat)-0.5,' ',min(lng)-0.5,
              ',', 
              min(lat)+0.5 ,' ',max(lng) +0.5,
              ')') AS box
   FROM addresses_import

//*************************************************
   SELECT *
  FROM branches
 WHERE MBRContains(
        GeomFromText( envelope('LINESTRING(33.20434400000000 -118.47817100000000,34.09832500000000 -117.35715400000000)') ),
       	POINT(lng, lat))

//*****************************************
select persons.user_id,  activities.id
from persons,branch_person,address_branch,activities
where persons.id = branch_person.person_id
and branch_person.role_id = 9
and branch_person.branch_id = address_branch.branch_id
and address_branch.address_id = activities.address_id
and activities.user_id = 0;

//*****************************************
SELECT activities.id, persons.user_id FROM `activities`,address_branch,branch_person,persons WHERE activities.user_id =0 and activities.address_id = address_branch.address_id and address_branch.branch_id = branch_person.branch_id and branch_person.person_id = persons.id
//***************************************
insert into activities

(`activity_date`,`activitytype_id`,`address_id`,`branch_id`,`user_id`,`relatedActivity`,`created_at`,`note`)
select * from (SELECT
          `followup_date`,'12',`address_id`,`branch_id`,`user_id`,`id`,`created_at`, concat_ws(' ','----',note,'----') from activities where followup_date is not null) b;


update`activities` set completed = 1 WHERE activity_date < '2019-03-30';

**********************************************************************
get closed won opportunities by branch / date
SELECT branch_id,DATE_FORMAT(actual_close, '%Y/%m/%d') as dateclosed, count(id) 
FROM `opportunities` 
WHERE actual_close is not null
and actual_close between cast('2019-01-01' as date) and cast('2019-03-31' as date)
group by branch_id,dateclosed

*********************************************************************
Get sales appt activities by branch / date
SELECT address_branch.branch_id as branch,DATE_FORMAT(activity_date, '%Y/%m/%d') as activitydate, count(activities.id) 
FROM `activities` , address_branch
WHERE activity_date between cast('2019-01-01' as date) and cast('2019-03-31' as date)
and activitytype_id =4
and activities.address_id = address_branch.address_id
group by branch,activitydate

**************************************************
Get all opportunities, activities, contacts for branch
select addresses.id as aid, addresses.businessname,addresses.street,addresses.city,addresses.state,addresses.zip,addresses.phone,addresses.lat,addresses.lng, 
address_branch.id as abid,
opportunities.id as oppid, opportunities.description,opportunities.comments,opportunities.expected_close,opportunities.closed, opportunities.top50,opportunities.value,opportunities.requirements,opportunities.actual_close,opportunities.duration, 
activities.id as actid, activities.activity_date,activities.activitytype_id,activities.followup_date,activities.note, 
contacts.id as cid, contacts.fullname,contacts.firstname,contacts.lastname,contacts.title,contacts.contactphone,contacts.email from addresses,address_branch left join opportunities on address_branch.id = opportunities.address_branch_id left join activities on address_branch.address_id = activities.address_id left join contacts on address_branch.address_id = contacts.address_id where address_branch.branch_id = 7383 and address_branch.address_id = addresses.id
///
25502,52206,186508,186510,186513,186514,186516,186518,186521,186522,186523,186524,186525,186529,186530,186532,186534,186541,336208,336210,336215,336235,336772,336778,336806,336818,337387,338053,338062,338910,346450,346746,346806,346879,346908,346930,347126,347216,348528,348554,348632,349264,349311,349320,349323,358967,359037,391242,391244,391249,391268,391273,392636,392642

SELECT 
    IF(ISNULL(user_id), 'NULL', 'NOT NULL') as myfield, 
    COUNT(*) 
FROM addresses 

GROUP BY myfield
****************************************************
KPI's
****************************************************
// branch_id   leads   opportys  leadconv  lagdays   velocitydays  avgdeal  won

select address_branch.branch_id,
count(address_branch.id) as leads,
count(b.id) + count(c.id) + count(d.id) as opptys,
count(a.id) / count(address_branch.id) as conv,
avg(datediff(a.created_at, address_branch.created_at)) as lagdays,
avg(datediff(a.actual_close, a.created_at)) as velocitydays,
avg(a.value) as avgdeal,
count(b.id) as open,
count(c.id) as won,
count(d.id) as lost,
count(c.id) / (count(c.id) + count(d.id)) as winratio
from address_branch

left join opportunities a on address_branch.id = a.address_branch_id
left join opportunities b on address_branch.id = b.address_branch_id and b.closed = 0
left join opportunities c on address_branch.id = c.address_branch_id and c.closed = 1
left join opportunities d on address_branch.id = d.address_branch_id and d.closed = 2
where address_branch.created_at > '2019-03-01'
//where address_branch.branch_id in ()
group by address_branch.branch_id

//////////////////////////////
select branchname,count(opportunities.id),count(opportunities.top50)
from branches,opportunities
where branches.id = opportunities.branch_id
and opportunities.closed = 0
group by branchname
/////////////////////////////////////////////////

branch::whereHas(opportunities,function($q){
  $q->where('closed','=',0);
})->select('branchname', DB::raw('count(opportunities.id) as open,count(opportunities.top50 as top50'))->groupBy('branchname')->get();


 /// Get random addresses

SELECT @min := MIN(id), @max := MAX(id) FROM addresses;
SELECT DISTINCT id, businessname, street, address2, city, state, zip, lat, lng FROM addresses AS a JOIN ( SELECT FLOOR(@min + (@max - @min + 1) * RAND()) AS id FROM addresses LIMIT 50 -- more than 10 (to compensate for dups) ) b USING (id) LIMIT 25

<<<<<<< Updated upstream

/////////////////////////////////////////////////
Check if branch managers report to the branches MM

SELECT a.branch_id, 
    concat_ws(' ', c.firstname, c.lastname) as 'Branch Manager', 
    concat_ws(' ', e.firstname, e.lastname) as 'Reports to Manager',
    concat_ws(' ', f.firstname, f.lastname) as 'Who Reports',
    concat_ws(' ', d.firstname, d.lastname) as 'Branch MM',
    concat_ws(' ', g.firstname, g.lastname) as 'Who Reports'
    
from persons c, persons d, persons e, persons f, persons g, branch_person a

left join branch_person b
on a.branch_id = b.branch_id

where a.role_id = 9
and c.deleted_at is null
and d.deleted_at is null
and b.role_id = 3
and a.person_id = c.id
and b.person_id != c.reports_to
and b.person_id = d.id
and c.reports_to = e.id
and e.reports_to = f.id
and d.reports_to = g.id
=======
/////////////////// Open Opportunities with no expected close date
select branches.id, branchname, concat_ws(' ', firstname, lastname), title, value, opportunities.created_at
from opportunities, branches, persons, branch_person
where opportunities.expected_close = null
and opportunities.closed = 0
and opportunities.branch_id = branches.id
and branches.id = branch_person.branch_id
and branch_person.role_id = 9
and branch_person.person_id = persons.id
and persons.deleted_at is null
>>>>>>> Stashed changes
